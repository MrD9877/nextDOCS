# Error in next/bable
go to .eslint file and change
```
{
  "extends": [
    "next/babel",
    "next/core-web-vitals"
  ]
}
```
# Special files in next
**page.js**\
**layout.js**\
**not-found.js**\
**template.js**\
**loading.js**\
**error.js**\
**delault.js**\
**route.js**\
**middleware.js**

# Routing
## Dynamic Routing
use [anyname] for dynamic routing\
params to ref route\
```
export default async function Reviews({ params }) {
    const par = await params
    const { blogerID, reviews } = par
    }
```
## Catch all segments
use [...anyname] to catch all segments
```
//remember p is a object containing all catched segments destructure before use.
export default async function NotFound({ params }) {
    const p = await params
    const { book } = p
    }
```
## Remove file from route or private file
if you do not want file to route yet use ***_filename***

## Group routes
To group a similar intent routes use **(filename)**

# Layout
```
export const metadata = {
  title: 'Next.js',
  description: 'Generated by Next.js',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```
## Tailwind in layout 
```
 import '../globals.css'
 ```

# Meta data
metadata is read from outer to inner and inner metadata rewright previous metadata.
```
export const metadata = {
  title: 'Next.js',
  description: 'Generated by Next.js',
}
```
## Dynamic metadata
```
export async function generateMetadata({ params, searchParams }, parent) {
  // read route params
  const id = (await params).id
 
  // fetch data
  const product = await fetch(`https://.../${id}`).then((res) => res.json())
 
  // optionally access and extend (rather than replace) parent metadata
  const previousImages = (await parent).openGraph?.images || []
 
  return {
    title: product.title,
    openGraph: {
      images: ['/some-specific-page-image.jpg', ...previousImages],
    },
  }
}
 
export default function Page({ params, searchParams }) {}
```
## Titile Object
absolute if do not want to change\
template if editing with nested title\
default in case no title in nexted routes\
```
export const metadata = {
  title: {
    default: '...',
    template: '%s | anyTitle',
    absolute: '...',
  },
}
```
# Navigate
next use Link like react but use href tag
```
import Link from "next/link"
```
```
<Link href="/about">About US<Link/>
```
**replace** replace history of tab
```
<Link href="/about" replace>About US<Link/>

```

## Styling link tag 
pathname return path we are nevigated to ex : "/about"/
```
'use client'
import { usePathname } from 'next/navigation'
const pathname = usePathname()
 ```

### UseRouter
The useRouter hook allows you to programmatically change.
```
 
import { useRouter } from 'next/navigation'
 
const router = useRouter()
 
router.push('/dashboard')
//default scroll to top of routed page.
router.push('/dashboard',{ scroll: false })
router.replace('/dashboard')
```
# Templates
Nameing file templates.js insted of layout.js rerender all components and state in templets usefull when to rerender in specific senarious\
**template.js**\
use both layout and template to rerender specific states\

# Loading
loading.js wrap whole file in suspence component

# Error
error.js shows error for given component and keep our whole site from crashing
```
'use client' // Error boundaries must be Client Components
 
import { useEffect } from 'react'
 
export default function Error({ error, reset }) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])
 
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  )
}
```
# Parllel routing
@filename\
to access component destructure them from props\
```
export default function Layout({ children, team, analytics }) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```
**pro**\
as per there conterparts components they benifit from next custom error,loading files where loading and error problems do not stop whole page.\

# Unmached Routes
use dalfault.js\

# Conditional Routes
You can use Parallel Routes to conditionally render routes based on certain conditions, such as user role. For example, to render a different dashboard page for the /admin or /user roles:
```
import { checkUserRole } from '@/lib/auth'
 
export default function Layout({ user, admin }) {
  const role = checkUserRole()
  return <>{role === 'admin' ? admin : user}</>
}
```
# Intercepting Routeing
use (.)**nameOfFile**\
(.) to match segments on the same level\
(..) to match segments one level above\
(..)(..) to match segments two levels above\
(...) to match segments from the root app directory\

# Server side next 
use file name **route.js**

## GET
```
export async function GET(params) {
    return new Response("hello world")
}
```
## POST
```
export async function POST(request) {
    const body = await request.json()
    const { username, password } = body
    const user = { username: username, password: password }
    users.push(user)
    console.log(users)
    return new Response(JSON.stringify(user), {
        headers: {
            "Content-Type": "application/json"
        },
        status: 201,
    })
}
```
## Dynamic Route handle
use [**filename**] 
```
//filename [id]
export async function GET(request, { params }) {
    const {id} = await params
    console.log(id)
    return new Response(id.id)
}
```

## URL query
```
export async function GET(request) {
    const searchParams = request.nextUrl.searchParams
    const query = searchParams.get("query")
    const name = searchParams.get("name")
    console.log(query, name)
    return new Response("hello world")
}
```
## Redirect
```
import { redirect } from "next/navigation"
redirect("/api")
```

## Headers
### Way1
```
export async function GET(request) {
    const reqHeader = new Headers(request.headers)
    const auth = reqHeader.get("Authorization")
    console.log(auth)
    return new Response("hello world")
}
```
### Way2
```
 import { headers } from "next/headers"
 export async function GET(request) {
  const headerList = await headers()
  const authHeader = headerList.get("Authorization")
  console.log(authHeader)
  return new Response("hello world")
}
```
## Set Cookies
### 1
```
export async function GET(request) {
    return new Response("<h1>hello world</h1>", {
        headers: {
            "content-Type": "text/html",
            "Set-Cookie": "id=98"
        }
    })
}
```
### 2
```
import { cookies } from "next/headers"

export async function GET(request) {
  cookies.set("name","value")
    return new Response("<h1>hello world</h1>", {
        headers: {
            "content-Type": "text/html",
        }
    })
}
```


## Get Cookies
### 1
```
export async function GET(request) {
    const id = request.cookies.get("id")
    console.log(id)
    return new Response("<h1>hello world</h1>")
}
```
### 2
```
import { cookies } from "next/headers"

export async function GET(request) {
const id cookies.get("name","value")
console.log(id)
return new Response("<h1>hello world</h1>")
}
```

## Catching 
use code below for next to stop catching
```
export const dynamic = "force-dynamic"
```
## MiddleWare in next
use **middleware.js** file in src folder
NextResponse is very useful in middle for more go to :https://nextjs.org/docs/app/api-reference/functions/next-response
```
import { NextResponse } from 'next/server'
export function middleware(){
const responce = NextResponse.next()
 //code  here
return responce
} 
```
# Rendering

## CLIENT-SIDE-RENDERING
! On request a html and js reference is sent in response/
! js is reqested from previous refrence/
! html is generated from response js and intractive ui is created

### Draw back

***SEO***/
A single div in a html is not optimal for seo,as it provide little content for crawler to index

***Performance***/
Having browser handle all work of fetching data,computing UI and making html interative slows thing down as js file size increase due to new added feachers it makes case worst.

## SERVER-SIDE SOLUTION
! on request a html is genetaed on server and sent with js reference in response
! browser display non-intractive html and req js reference 
! js reference is sent in response which is then hydrated by react 

### SERVER-SIDE SOLUTION TYPES

***STATIC SITE GENRATION (SSG)***/
SSG happens when application is build and deploy on server as pages are already render and ready to serve its ideal for site with blog as content do not change much.

***SERVER-SIDE RENDERING (SSR)***/
SSR render pages on-demand and good for site like social meadia

### Drawbacks
***All or nothing waterfall***
1) Components can't stop rendering while loading data /
if component need to fetch data from extarnal source server must load data before rendering./
This delay server respose to browser/
2) for react to hydrate components in browser must match component tree in server which means all js must be loaded before react can start hydrating any component./
3) All component must be hydrated before you can interact with any component

## SUSPENCE FOR SSR 
1) HTML streaming on server /
By wraping a content in ***suspence*** it tell react to start streaming rest of html /
Code splitting using ***React.lazy*** allow you to mark a specific code not for immediately loading and signal budler to segregrate in differnt script tag./
2) Selective hydration on client/
Using ***suspence*** prevent rest of code from not hydrating /
Selective hydration allow user to intract with rest of components in page/
Selective hydration priotize based on user interation/

### Drawbacks
1) Should user need to download so much data?
2) Should all component be hydrated even those that do not need interactivity?
3) Should so much of work be done on user's device? 

## Server Side components
1) server side componets do not send code to client allow large dependency to stay on server.
2) It removes hydration step,speeding up app loading and interation.
3) It directly fetch data and render it to component.
4) It increase security by keeping sensitive logic and data on server.
5) It allows server to catch result for later request from same or differnt user.
6) Improve SEO

## Server-only Code
```
npm i server-only
```
```
import "server-only"
```
## Client-only Code
```
npm i client-only
```
```
import "client-only"
```


